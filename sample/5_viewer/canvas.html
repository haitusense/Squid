<!-- 
  canvasの高速化
  1. 透過をやめる
    var ctx = canvas.getContext('2d', { alpha: false })
  2. CSS 座標変換を使用してキャンバスを拡大縮小する  
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
</head>

<style type="text/css">
  #canvas { 
    image-rendering: pixelated;
    position: absolute;
    transform-origin: 0px 0px;
    z-index: 2;
  }
  #stage {
    position: relative;
    transform-origin: 0px 0px;
    padding: 50px;
  }
  #stage:focus { outline: none; }
  #stalker {
    pointer-events: none;
    position: fixed;
    top: 12px;
    left: 18px;
    transform: translate(0, 0);
    transform-origin: 0px 0px;
    background: #eee;
    z-index: 800;
  }
</style>

<body>
  <div id="stalker"></div>
  <div id="stage" tabindex="0">
    <canvas id="canvas"></canvas>
  </div>
</body>


<script>
const params = {
  pipe : "NamedPipe_canvas",
  mmf : "mmf_canvas",
  path : "sample.jpg",
  width : 640,
  height : 480,
  maxsize : 2073600 //1920x1080
};

const cnv_params = {
  scale_step : 0.2,
  scale : 1,
  bitshift : 0,
  color : true,
  scale_up : function(){ this.scale = Math.round( (this.scale + this.scale_step) * 10 ) / 10 },
  scale_down : function(){ 
    this.scale = Math.round( (this.scale - this.scale_step) * 10 ) / 10;
    if(this.scale < this.scale_step) this.scale = this.scale_step;
  }
};

window.addEventListener('load', async () =>{
  console.log('load');
  chrome.webview.hostObjects.Squid.OpenMemoryMap(params.mmf, params.maxsize);
  chrome.webview.hostObjects.Squid.OpenNamedPipe(params.pipe);
  await readRaw();

  // window.addEventListener('resize', () => {
  //   let dst = (window.innerWidth - stage.offsetWidth) / 2;
  //   stage.style.marginLeft = dst > 0 ? dst : 0;
  // });

  SquidJS.addKeyMouseEvent(stage, 
  { },
  async (event, key)=>{
    switch (key) {
      case 'MouseLeave':
        stage.blur();
        break;
      case 'MouseEnter':
        stage.focus();
        break;
      case 'MouseMove':
        const x = Math.trunc((event.clientX - canvas.getBoundingClientRect().left) / cnv_params.scale);
        const y = Math.trunc((event.clientY - canvas.getBoundingClientRect().top) / cnv_params.scale);
        const inCnv = 0 <= x && x < params.width && 0 <= y && y < params.height; 
        window.chrome.webview.postMessage(`(${x},${y}) ${inCnv}`);
        let dst = null;
        if(!inCnv) return;
        if(cnv_params.color){
          let ctx = canvas.getContext('2d', { alpha: false });
          let result_rgba = ctx.getImageData(x, y, 1, 1).data;
          dst = `R${result_rgba[0]},G${result_rgba[1]},B${result_rgba[2]}`
        }else{
          let result_mono = await chrome.webview.hostObjects.Squid.ReadMemoryMapSingle(x + y * params.width);
          dst = `${result_mono}`
        }
        stalker.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`
        stalker.textContent = `(${x},${y}) ${dst}`;
        break;
      case 'Shift+WheelUP':
        event.preventDefault();
        cnv_params.bitshift += 1;
        await cnv_refresh(true);
        window.chrome.webview.postMessage(`x${cnv_params.scale} shift ${cnv_params.bitshift}`);
        break;
      case 'Shift+WheelDOWN':
        event.preventDefault();
        cnv_params.bitshift -= 1;
        await cnv_refresh(true);
        window.chrome.webview.postMessage(`x${cnv_params.scale} shift ${cnv_params.bitshift}`);
        break;
      case 'Alt+WheelUP':
        event.preventDefault();
        cnv_params.scale_up();
        await cnv_refresh(false);
        window.chrome.webview.postMessage(`x${cnv_params.scale} shift ${cnv_params.bitshift}`);
        break;
      case 'Alt+WheelDOWN':
        event.preventDefault();
        cnv_params.scale_down();
        await cnv_refresh(false);
        window.chrome.webview.postMessage(`x${cnv_params.scale} shift ${cnv_params.bitshift}`);
        break;
      case 'Alt+KeyC':
        cnv_params.color = !cnv_params.color;
        await cnv_refresh(true);
        break;
      default:
    }
  })

});

// addEventListener webview message
SquidJS.setMessageEventListener(async (json) => {
  console.log(json);
  if(json.id == "draw"){
    console.log("cnv_refresh");
    
    params.width = json.width;
    params.height = json.height;
    await cnv_refresh(true);
  }
});

const readRaw = async ()=>{
  const squid = chrome.webview.hostObjects.Squid;
  
  const args = Object.assign({ flag : "demosaic" }, params);
    await squid.CallProcessAsync(
    "dotnet",
    `script ./reader.csx -- ${JSON.stringify(JSON.stringify(args))} `,
    false,
    null
  );
}

const cnv_refresh = async (flag) => {
  // stage.style.transform = `scale(${cnv_params.scale})`;
  stage.style.width = params.width * cnv_params.scale;
  stage.style.height = params.height * cnv_params.scale;
  canvas.style.transform = `scale(${cnv_params.scale})`;

  const { clientWidth : w , clientHeight : h } =  canvas;
  if(w !== params.width || h !==  params.height ){
    canvas.setAttribute( "width", params.width );
    canvas.setAttribute( "height", params.height );
  }

  if(!flag) return;
  if(cnv_params.color){
    await SquidJS.drawFromMemoryMap('canvas', 'bayerGR', cnv_params.bitshift)
  }else{
    await SquidJS.drawFromMemoryMap('canvas', 'mono', cnv_params.bitshift)
  }
}

</script>
</html>
